\documentclass[11pt,a4paper]{article}

%=========== PACKAGES ===========
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage[
  colorlinks=true,
  linkcolor=black, % Color for internal links
  urlcolor=blue,   % Color for web links
  citecolor=black  % Color for citations
]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{graphicx}

%=========== DOCUMENT GEOMETRY ===========
\geometry{margin=1in}

%=========== METADATA FOR PDF ===========
\hypersetup{
  pdftitle={Charity Project: Software Design Documentation},
  pdfauthor={Generated by Gemini},
  pdfsubject={An analysis of design patterns in a PHP application.}
}

%=========== CODE LISTING STYLE ===========
% Define colors for syntax highlighting
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codered}{rgb}{0.8,0.1,0.1}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}

% Define the style for PHP code
\lstdefinestyle{phpstyle}{
  language=PHP,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{codeblue}\bfseries,
  commentstyle=\color{codegray}\itshape,
  stringstyle=\color{codered},
  backgroundcolor=\color{white},
  showstringspaces=false,
  breaklines=true,              % Automatically break long lines
  breakatwhitespace=true,       % Break lines only at whitespace
  numbers=left,
  numberstyle=\tiny\color{codegray},
  frame=single,                 % Add a frame around the code
  framerule=0.4pt,
  rulecolor=\color{black},
  columns=fullflexible,         % Avoid fixed-width columns
  captionpos=b,                 % Caption below the listing
  title=\lstname,               % Show the filename in the title
}
\lstset{style=phpstyle} % Set the default style for all listings

%=========== TITLE PAGE INFORMATION ===========
\title{
  \vspace{2cm} % Add space at the top
  \Huge Charity Project \\
  \vspace{0.5cm}
  \Large Software Design and Architecture Documentation
  \vspace{2cm}
}
\author{
  Project Author Name \\ %<-- Replace with your name
  \texttt{author@email.com} %<-- Replace with your email
}
\date{\today}


%================================================
%============== DOCUMENT BEGINS HERE ============
%================================================
\begin{document}

% --- Cover Page ---
\maketitle
\thispagestyle{empty} % No page number on the cover page

\newpage

% --- Table of Contents ---
\tableofcontents

\newpage

% --- Introduction ---
\section{Introduction}
This document provides a detailed analysis of the software architecture and design patterns implemented in the Charity PHP project. The system is designed around a core architectural pattern (MVC) and several creational, structural, and behavioral design patterns that ensure separation of concerns, flexibility, and maintainability.

Each section that follows will describe a specific pattern, explain its role and implementation within the project, and present the relevant code excerpts directly from the source files for clear illustration.

\section{Architectural Patterns}

\subsection{Model-View-Controller (MVC)}
\textbf{Intent:} MVC is an architectural pattern that separates an application into three interconnected components: the Model, the View, and the Controller. This separation is crucial for organizing the codebase and decoupling the business logic from the user interface.

\textbf{Implementation:} The project's directory structure clearly reflects the MVC pattern:
\begin{itemize}
    \item \textbf{Model:} Located in `src/models/`, files like `users.php`, `payments.php`, and `events.php` manage the application's data, business rules, and logic. They are responsible for interacting with the database and representing the core entities of the system.
    \item \textbf{View:} Located in `src/views/`, these are the PHP template files responsible for presenting data to the user. They contain the HTML structure and minimal PHP logic for displaying information provided by the controller. The `layout.php` file acts as a master template.
    \item \textbf{Controller:} Located in `src/controllers/`, these files act as the intermediary between the Model and the View. They handle user input from the request, interact with the Model to fetch or update data, and then select the appropriate View to render the response.
\end{itemize}

The `Router` dispatches requests to the appropriate Controller, which then completes the cycle.

\section{Creational Design Patterns}

\subsection{Singleton}
\textbf{Intent:} The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is used for managing shared resources like database connections, log files, and the application router.

\textbf{Implementation:} A generic `Singleton` abstract class provides the core functionality. The `Database`, `Logger`, and `Router` classes extend it. The static method `getInstance()` is the global access point to the single instance of each class.

\begin{lstlisting}[caption={The Singleton base class and Database implementation.}, label={lst:singleton}]
% Filepath: src\core\singletons.php
<?php
abstract class Singleton
{
	private static $instances = [];

	protected function __construct() {}
	// ... (clone and wakeup are protected)

	public static function getInstance(): static
	{
		$cls = static::class;
		if (!isset(self::$instances[$cls])) {
			self::$instances[$cls] = new static;
		}
		return self::$instances[$cls];
	}
}

class Database extends Singleton
{
	private $dbh;
    // ... constructor
	public static function getHandle(): PDO
	{
		return self::getInstance()->dbh;
	}
}
\end{lstlisting}

\section{Structural Design Patterns}

\subsection{Decorator}
\textbf{Intent:} The Decorator pattern adds new responsibilities to an object dynamically without altering its class. It involves a "wrapper" object that contains the original object.

\textbf{Implementation:} `ProtectedHandler` is a Decorator that adds access control to any `Handler` object. It extends the abstract `RouteDecorator` and wraps a concrete `Handler`. When a method (e.g., `GET`, `POST`) is called, `ProtectedHandler` first executes its security checks (is the user logged in? do they have the required role?). If the checks pass, it delegates the call to the wrapped `Handler` object, which proceeds with the core business logic.

\begin{lstlisting}[caption={The Decorator for adding role-based access control.}, label={lst:decorator}]
% Filepath: src\core\ProtectedHandler.php
<?php
abstract class RouteDecorator extends Handler
{
	protected $wrappee;

	public function __construct(Handler $wrappee)
	{
		$this->wrappee = $wrappee;
	}
}

class ProtectedHandler extends RouteDecorator
{
	private $requiredRole;

	public function __construct(Handler $wrappee, string $requiredRole)
	{
		parent::__construct($wrappee);
		$this->requiredRole = $requiredRole;
	}

	public function __call($method, $args)
	{
		if (!isset($_SESSION['user'])) {
			http_error(401);
		}
		if (!$_SESSION['user'] instanceof $this->requiredRole) {
			http_error(403);
		}
		return call_user_func_array([$this->wrappee, $method], $args);
	}
}
\end{lstlisting}
\begin{lstlisting}[caption={Applying the decorator to a controller route.}, label={lst:decorator-usage}]
% Filepath: src\controllers\admin\fundraisers.php
<?php
// ... (requires)
$handler = new class extends Handler
{
	public function GET() { /* ... */ }
	public function POST() { /* ... */ }
};

return new ProtectedHandler($handler, Admin::class);
\end{lstlisting}

\section{Behavioral Design Patterns}

\subsection{Strategy}
\textbf{Intent:} The Strategy pattern defines a family of interchangeable algorithms and encapsulates each one. This allows the algorithm to be selected at runtime.

\textbf{Implementation:} The application handles different payment methods using the Strategy pattern. The `PaymentMethod` interface defines the contract for all payment algorithms. Concrete classes like `CreditCardPayment` and `PayPalPayment` provide specific implementations. The `Donor` class (the "Context") holds a `PaymentMethod` object, allowing it to process payments without being coupled to a specific payment provider. The strategy is chosen in the `Donor::parse` method based on user data.

\begin{lstlisting}[caption={The Strategy interface and its context.}, label={lst:strategy}]
% Filepath: src\models\payments.php & src\models\users.php
<?php
// In payments.php
interface PaymentMethod
{
	public function pay(float $amount): void;
}

class CreditCardPayment implements PaymentMethod { /* ... */ }
class PayPalPayment implements PaymentMethod { /* ... */ }

// In users.php
class Donor extends User
{
	public PaymentMethod $paymentMethod;

	public function parse(array $data)
	{
		$this->paymentMethod = match ($data['payment_method'] ?? 'credit_card') {
			'credit_card' => new CreditCardPayment,
			'paypal' => new PayPalPayment,
			'bank_transfer' => new BankTransferPayment,
		};
	}
    // ...
}
\end{lstlisting}

\subsection{State}
\textbf{Intent:} The State pattern allows an object to change its behavior when its internal state changes. The object appears to change its class.

\textbf{Implementation:} The `Donation` object transitions through a lifecycle (`Created`, `Pending`, `Accepted`, `Cancelled`). The `DonationState` abstract class defines the common interface for all states. Each concrete state class (`CreatedState`, `PendingState`, etc.) implements behavior specific to that state. The `Donation` object (the "Context") holds a reference to its current state object and delegates actions to it, transitioning to a new state when an action is completed.

\begin{lstlisting}[caption={The State pattern for the Donation lifecycle.}, label={lst:state}]
% Filepath: src\models\payments.php
<?php
class Donation
{
	public DonationState $state;

	public function __construct(float $amount, Donor $donor)
	{
		// ...
		$this->state = new CreatedState($this);
	}

	public function proceed() { $this->state->proceed(); }
	public function cancel() { $this->state->cancel(); }
}

abstract class DonationState
{
	protected Donation $donation;
	public function __construct(Donation $donation) { /* ... */ }
	abstract public function proceed();
	abstract public function cancel();
}

class CreatedState extends DonationState
{
	public function proceed()
	{
		// ... logic for processing a new donation
		$this->donation->state = new PendingState($this->donation);
	}
    // ...
}
\end{lstlisting}

\subsection{Iterator}
\textbf{Intent:} The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

\textbf{Implementation:} The project uses the Iterator pattern in two distinct ways:
\begin{enumerate}
    \item \textbf{Controller Discovery:} In `index.php`, `RecursiveDirectoryIterator` and `RecursiveIteratorIterator` are used to traverse the `controllers` directory to find and register all route handlers automatically.
    \item \textbf{Data Fetching:} In `Donation::getAllPending()`, the `yield` keyword is used to create a generator. A generator is PHP's implementation of the Iterator pattern, allowing it to fetch and return one pending donation at a time, which is highly memory-efficient for large datasets.
\end{enumerate}

\begin{lstlisting}[caption={Using iterators for automatic route discovery.}, label={lst:iterator-discovery}]
% Filepath: src\index.php
<?php
$controllers_iterator = new RecursiveIteratorIterator(
	new RecursiveDirectoryIterator('controllers')
);

foreach ($controllers_iterator as $controller => $fileinfo) {
	if ($fileinfo->getExtension() === 'php') {
		// ... (logic to register route)
		$router->register($route, $controller);
	}
}
\end{lstlisting}

\begin{lstlisting}[caption={Using a generator (Iterator) for efficient data fetching.}, label={lst:iterator-yield}]
% Filepath: src\models\payments.php
<?php
class Donation {
    // ...
	public static function getAllPending()
	{
		// ... (database query)
		foreach ($rows as $row) {
			// ... (object creation)
			yield $donation;
		}
	}
    // ...
}
\end{lstlisting}

\subsection{Observer}
\textbf{Intent:} The Observer pattern defines a one-to-many dependency between objects, so that when one object (the subject) changes state, all its dependents (observers) are notified and updated automatically.

\textbf{Implementation:} The `EventManager` (the "Subject") maintains a list of `EventListener` objects (the "Observers"). When a significant event occurs, such as a `Fundraiser` being saved, the `EventManager`'s `notify()` method is called. This method iterates through all subscribed listeners and calls their `update()` method. This decouples the business logic of creating a fundraiser from subsequent actions like sending notifications.

\begin{lstlisting}[caption={The Observer pattern implementation.}, label={lst:observer}]
% Filepath: src\models\events.php
<?php
interface EventListener
{
	public function update(string $data);
	// ...
}

class EventManager extends Singleton
{
	private array $listeners;
	// ...
	public function notify(string $eventType, string $data)
	{
		if (!isset($this->listeners[$eventType])) return;
		foreach ($this->listeners[$eventType] as $listener) {
			$listener->update($data);
		}
	}
}

class Fundraiser
{
	public function save(): void
	{
		// ... (saves fundraiser to database)
		$eventManager = EventManager::getInstance();
		$eventManager->notify('fundraisers', "{$this->title} on {$this->date}");
	}
}
\end{lstlisting}

\subsection{Template Method}
\textbf{Intent:} The Template Method pattern defines the skeleton of an algorithm in a base class but lets subclasses override specific steps of the algorithm without changing its structure.

\textbf{Implementation:} The abstract `User` class defines the main algorithm for user creation in its constructor. The constructor is the "template method": it handles common initialization steps like setting the ID, email, etc., and then calls the abstract `parse()` method. Each concrete subclass (`Admin`, `Volunteer`, `Donor`, `Beneficiary`) must provide its own implementation of `parse()` to handle the specific data structure associated with that user type.

\begin{lstlisting}[caption={The Template Method pattern in the User hierarchy.}, label={lst:template-method}]
% Filepath: src\models\users.php
<?php
abstract class User implements EventListener
{
	public function __construct(array $row)
	{
		$this->id = $row['id'];
		$this->name = $row['name'];
		$this->email = $row['email'];
		// ... common steps
		
		// Call the abstract method to be defined by subclasses
		$this->parse(json_decode($row['data'], true));
	}

	// This is the step that subclasses must implement
	abstract public function parse(array $data);
}

class Volunteer extends User
{
	public $skills, $availability;

	// Concrete implementation of the abstract step
	public function parse($data)
	{
		$this->skills = $data['skills'] ?? [];
		$this->availability = $data['availability'] ?? [];
	}
    // ...
}

class Donor extends User
{
	public PaymentMethod $paymentMethod;

	// A different implementation of the same abstract step
	public function parse(array $data)
	{
		$this->paymentMethod = match ($data['payment_method'] ?? 'credit_card') {
			// ...
		};
	}
    // ...
}
\end{lstlisting}

\end{document}